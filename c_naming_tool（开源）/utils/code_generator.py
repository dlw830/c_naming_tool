"""
代码生成器模块
负责生成格式化的C代码
"""

from datetime import datetime
from core.type_info import type_info_manager


class CodeGenerator:
    """代码生成器"""
    
    def __init__(self):
        """初始化代码生成器"""
        self.file_header_template = """/*******************************************************************************
 * @file    {filename}
 * @brief   Variable definitions generated by C Naming Tool
 * @date    {date}
 * @version 1.0.0
 ******************************************************************************/

#include <stdint.h>
#include <stdbool.h>

"""
    
    def generate_variable_code(self, var_name, var_type, modifier, module, 
                               purpose, initial_value="0", comment=""):
        """
        生成基础变量定义代码
        
        Args:
            var_name: 变量名
            var_type: 变量类型
            modifier: 修饰类型
            module: 功能模块
            purpose: 使用目的
            initial_value: 初始值
            comment: 额外注释
            
        Returns:
            str: 生成的代码
        """
        # 获取类型信息
        type_info = type_info_manager.get_type_info(var_type)
        range_str = type_info_manager.get_range_str(var_type)
        bytes_str = type_info.get('bytes', 0)
        
        # 生成注释块
        code = f"""/*******************************************************************************
 * 变量名称: {var_name}
 * 变量类型: {var_type}
 * 取值范围: {range_str}
 * 内存占用: {bytes_str} bytes
 * 功能模块: {module}
 * 使用目的: {purpose}
 * 修饰属性: {modifier}
"""
        
        if comment:
            code += f" * 备注: {comment}\n"
        
        code += " ******************************************************************************/\n"
        
        # 生成变量定义
        storage_class = ""
        if modifier == "静态变量":
            storage_class = "static "
        elif modifier == "常量":
            storage_class = "const "
        elif modifier == "volatile":
            storage_class = "volatile "
        
        code += f"{storage_class}{var_type} {var_name} = {initial_value};\n\n"
        
        return code
    
    def generate_array_code(self, var_name, element_type, array_size, 
                           modifier, module, purpose, comment=""):
        """
        生成数组定义代码
        
        Args:
            var_name: 数组名
            element_type: 元素类型
            array_size: 数组大小
            modifier: 修饰类型
            module: 功能模块
            purpose: 使用目的
            comment: 额外注释
            
        Returns:
            str: 生成的代码
        """
        # 获取类型信息
        range_str = type_info_manager.get_range_str(element_type)
        total_bytes, memory_str = type_info_manager.get_memory_size(element_type, array_size)
        element_bytes = type_info_manager.get_type_info(element_type).get('bytes', 0)
        
        # 生成注释块
        code = f"""/*******************************************************************************
 * 变量名称: {var_name}
 * 变量类型: {element_type}[{array_size}]
 * 元素范围: {range_str}
 * 数组大小: {array_size}
 * 内存占用: {memory_str} ({element_bytes} bytes × {array_size})
 * 功能模块: {module}
 * 使用目的: {purpose}
 * 修饰属性: {modifier}
"""
        
        if comment:
            code += f" * 备注: {comment}\n"
        
        code += " ******************************************************************************/\n"
        
        # 生成数组定义
        storage_class = ""
        if modifier == "静态变量":
            storage_class = "static "
        elif modifier == "常量":
            storage_class = "const "
        
        code += f"{storage_class}{element_type} {var_name}[{array_size}] = {{0}};\n\n"
        
        return code
    
    def generate_struct_code(self, struct_name, members, comment=""):
        """
        生成结构体定义代码
        
        Args:
            struct_name: 结构体名称（不含_t后缀）
            members: 成员列表，每个成员是字典 {'type': '', 'name': '', 'comment': ''}
            comment: 结构体注释
            
        Returns:
            str: 生成的代码
        """
        # 计算结构体大小和对齐
        total_size, aligned_size, padding = self._calculate_struct_size(members)
        
        # 生成注释块
        code = f"""/*******************************************************************************
 * 结构体名称: {struct_name}_t
 * 功能描述: {comment if comment else struct_name}
 * 总大小: {aligned_size} bytes (4字节对齐)
 * 成员数量: {len(members)}
"""
        
        if padding > 0:
            code += f" * 填充字节: {padding} bytes\n"
        
        code += " ******************************************************************************/\n"
        
        # 生成结构体定义
        code += "typedef struct {\n"
        
        offset = 0
        for i, member in enumerate(members):
            member_type = member['type']
            member_name = member['name']
            member_comment = member.get('comment', '')
            
            # 获取成员类型信息
            type_info = type_info_manager.get_type_info(member_type)
            range_str = type_info_manager.get_range_str(member_type)
            member_bytes = type_info.get('bytes', 0)
            
            # 计算对齐
            if member_bytes > 0:
                alignment = min(member_bytes, 4)  # 假设最大4字节对齐
                if offset % alignment != 0:
                    offset += alignment - (offset % alignment)
            
            # 生成成员定义
            padding_str = f"Offset: {offset}" if i > 0 else f"Offset: {offset}"
            
            if member_comment:
                code += f"    {member_type:<12} {member_name};  // {member_comment}, Range: {range_str}, {padding_str}\n"
            else:
                code += f"    {member_type:<12} {member_name};  // Range: {range_str}, {padding_str}\n"
            
            offset += member_bytes
        
        code += f"}} {struct_name}_t;\n\n"
        
        return code
    
    def _calculate_struct_size(self, members):
        """
        计算结构体大小
        
        Args:
            members: 成员列表
            
        Returns:
            tuple: (未对齐大小, 对齐后大小, 填充字节数)
        """
        offset = 0
        max_alignment = 1
        
        for member in members:
            member_type = member['type']
            type_info = type_info_manager.get_type_info(member_type)
            member_bytes = type_info.get('bytes', 0)
            
            if member_bytes > 0:
                # 计算对齐
                alignment = min(member_bytes, 4)  # 假设最大4字节对齐
                max_alignment = max(max_alignment, alignment)
                
                # 对齐当前偏移
                if offset % alignment != 0:
                    offset += alignment - (offset % alignment)
                
                offset += member_bytes
        
        # 结构体末尾对齐
        unaligned_size = offset
        if offset % max_alignment != 0:
            aligned_size = offset + (max_alignment - offset % max_alignment)
        else:
            aligned_size = offset
        
        padding = aligned_size - unaligned_size
        
        return unaligned_size, aligned_size, padding
    
    def generate_enum_code(self, enum_name, values, comment=""):
        """
        生成枚举定义代码
        
        Args:
            enum_name: 枚举名称（不含_e后缀）
            values: 枚举值列表，每个值是字典 {'name': '', 'value': None, 'comment': ''}
            comment: 枚举注释
            
        Returns:
            str: 生成的代码
        """
        # 生成注释块
        code = f"""/*******************************************************************************
 * 枚举名称: {enum_name}_e
 * 功能描述: {comment if comment else enum_name}
 * 成员数量: {len(values)}
 ******************************************************************************/\n"""
        
        # 生成枚举定义
        code += f"typedef enum {{\n"
        
        for i, value in enumerate(values):
            value_name = value['name']
            value_num = value.get('value')
            value_comment = value.get('comment', '')
            
            # 生成枚举值定义
            if value_num is not None:
                code += f"    {value_name} = {value_num}"
            else:
                code += f"    {value_name}"
            
            # 添加逗号（最后一个除外）
            if i < len(values) - 1:
                code += ","
            
            # 添加注释
            if value_comment:
                code += f"  // {value_comment}"
            
            code += "\n"
        
        code += f"}} {enum_name}_e;\n\n"
        
        return code
    
    def generate_file(self, filename, definitions, include_header=True):
        """
        生成完整的C文件
        
        Args:
            filename: 文件名
            definitions: 定义列表（变量、结构体等代码）
            include_header: 是否包含文件头
            
        Returns:
            str: 完整的C文件内容
        """
        code = ""
        
        if include_header:
            date_str = datetime.now().strftime("%Y-%m-%d")
            code = self.file_header_template.format(
                filename=filename,
                date=date_str
            )
        
        # 添加所有定义
        for definition in definitions:
            code += definition
        
        # 添加文件结尾
        code += """/*******************************************************************************
 * End of file
 ******************************************************************************/\n"""
        
        return code


# 全局实例
code_generator = CodeGenerator()
